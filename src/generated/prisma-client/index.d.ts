// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  brand: (where?: BrandWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  feed: (where?: FeedWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productEntity: (where?: ProductEntityWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  brand: (where: BrandWhereUniqueInput) => BrandPromise;
  brands: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Brand>;
  brandsConnection: (args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BrandConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  feed: (where: FeedWhereUniqueInput) => FeedPromise;
  feeds: (args?: {
    where?: FeedWhereInput;
    orderBy?: FeedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Feed>;
  feedsConnection: (args?: {
    where?: FeedWhereInput;
    orderBy?: FeedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FeedConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productEntity: (where: ProductEntityWhereUniqueInput) => ProductEntityPromise;
  productEntities: (args?: {
    where?: ProductEntityWhereInput;
    orderBy?: ProductEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductEntity>;
  productEntitiesConnection: (args?: {
    where?: ProductEntityWhereInput;
    orderBy?: ProductEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductEntityConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBrand: (data: BrandCreateInput) => BrandPromise;
  updateBrand: (args: {
    data: BrandUpdateInput;
    where: BrandWhereUniqueInput;
  }) => BrandPromise;
  updateManyBrands: (args: {
    data: BrandUpdateManyMutationInput;
    where?: BrandWhereInput;
  }) => BatchPayloadPromise;
  upsertBrand: (args: {
    where: BrandWhereUniqueInput;
    create: BrandCreateInput;
    update: BrandUpdateInput;
  }) => BrandPromise;
  deleteBrand: (where: BrandWhereUniqueInput) => BrandPromise;
  deleteManyBrands: (where?: BrandWhereInput) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  updateManyCategories: (args: {
    data: CategoryUpdateManyMutationInput;
    where?: CategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createFeed: (data: FeedCreateInput) => FeedPromise;
  updateFeed: (args: {
    data: FeedUpdateInput;
    where: FeedWhereUniqueInput;
  }) => FeedPromise;
  updateManyFeeds: (args: {
    data: FeedUpdateManyMutationInput;
    where?: FeedWhereInput;
  }) => BatchPayloadPromise;
  upsertFeed: (args: {
    where: FeedWhereUniqueInput;
    create: FeedCreateInput;
    update: FeedUpdateInput;
  }) => FeedPromise;
  deleteFeed: (where: FeedWhereUniqueInput) => FeedPromise;
  deleteManyFeeds: (where?: FeedWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductEntity: (data: ProductEntityCreateInput) => ProductEntityPromise;
  updateProductEntity: (args: {
    data: ProductEntityUpdateInput;
    where: ProductEntityWhereUniqueInput;
  }) => ProductEntityPromise;
  updateManyProductEntities: (args: {
    data: ProductEntityUpdateManyMutationInput;
    where?: ProductEntityWhereInput;
  }) => BatchPayloadPromise;
  upsertProductEntity: (args: {
    where: ProductEntityWhereUniqueInput;
    create: ProductEntityCreateInput;
    update: ProductEntityUpdateInput;
  }) => ProductEntityPromise;
  deleteProductEntity: (
    where: ProductEntityWhereUniqueInput
  ) => ProductEntityPromise;
  deleteManyProductEntities: (
    where?: ProductEntityWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  brand: (
    where?: BrandSubscriptionWhereInput
  ) => BrandSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  feed: (
    where?: FeedSubscriptionWhereInput
  ) => FeedSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productEntity: (
    where?: ProductEntitySubscriptionWhereInput
  ) => ProductEntitySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC";

export type BrandOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "description_ASC"
  | "description_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "isFeatured_ASC"
  | "isFeatured_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "PID_ASC"
  | "PID_DESC"
  | "description_ASC"
  | "description_DESC";

export type ProductEntityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "releaseDate_ASC"
  | "releaseDate_DESC";

export type FeedOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "birthdate_ASC"
  | "birthdate_DESC"
  | "email_ASC"
  | "email_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CategoryUpdateManyWithoutDepartmentInput {
  create?:
    | CategoryCreateWithoutDepartmentInput[]
    | CategoryCreateWithoutDepartmentInput;
  delete?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  set?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  disconnect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  update?:
    | CategoryUpdateWithWhereUniqueWithoutDepartmentInput[]
    | CategoryUpdateWithWhereUniqueWithoutDepartmentInput;
  upsert?:
    | CategoryUpsertWithWhereUniqueWithoutDepartmentInput[]
    | CategoryUpsertWithWhereUniqueWithoutDepartmentInput;
  deleteMany?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  updateMany?:
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput;
}

export type BrandWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpdateWithoutCategoryDataInput {
  isFeatured?: Boolean;
  name?: String;
  slug?: String;
  PID?: String;
  description?: String;
  brand?: BrandUpdateOneRequiredWithoutProductInput;
  entity?: ProductEntityUpdateManyWithoutProductInput;
}

export interface DepartmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  brand_some?: BrandWhereInput;
  category_some?: CategoryWhereInput;
  images_some?: ImageWhereInput;
  images_every?: ImageRestrictedWhereInput;
  images_none?: ImageRestrictedWhereInput;
  AND?: DepartmentWhereInput[] | DepartmentWhereInput;
}

export interface CategoryUpdateWithWhereUniqueWithoutBrandInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutBrandDataInput;
}

export interface FeedUpsertWithWhereUniqueWithoutLikedInput {
  where: FeedWhereUniqueInput;
  update: FeedUpdateWithoutLikedDataInput;
  create: FeedCreateWithoutLikedInput;
}

export interface CategoryUpdateWithoutBrandDataInput {
  description?: String;
  name?: String;
  slug?: String;
  images?: ImageUpdateManyInput;
  department?: DepartmentUpdateManyWithoutCategoryInput;
  product?: ProductUpdateManyWithoutCategoryInput;
}

export interface BrandUpdateOneRequiredWithoutProductInput {
  create?: BrandCreateWithoutProductInput;
  update?: BrandUpdateWithoutProductDataInput;
  upsert?: BrandUpsertWithoutProductInput;
  connect?: BrandWhereUniqueInput;
}

export interface DepartmentUpdateManyWithoutCategoryInput {
  create?:
    | DepartmentCreateWithoutCategoryInput[]
    | DepartmentCreateWithoutCategoryInput;
  delete?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  set?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  disconnect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  update?:
    | DepartmentUpdateWithWhereUniqueWithoutCategoryInput[]
    | DepartmentUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | DepartmentUpsertWithWhereUniqueWithoutCategoryInput[]
    | DepartmentUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  updateMany?:
    | DepartmentUpdateManyWithWhereNestedInput[]
    | DepartmentUpdateManyWithWhereNestedInput;
}

export interface SizeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: SizeWhereInput[] | SizeWhereInput;
}

export interface DepartmentUpdateWithWhereUniqueWithoutCategoryInput {
  where: DepartmentWhereUniqueInput;
  data: DepartmentUpdateWithoutCategoryDataInput;
}

export interface BrandWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  images_some?: ImageWhereInput;
  images_every?: ImageRestrictedWhereInput;
  images_none?: ImageRestrictedWhereInput;
  category_some?: CategoryWhereInput;
  department_some?: DepartmentWhereInput;
  product_some?: ProductWhereInput;
  AND?: BrandWhereInput[] | BrandWhereInput;
}

export interface DepartmentUpdateWithoutCategoryDataInput {
  description?: String;
  name?: String;
  slug?: String;
  brand?: BrandUpdateManyWithoutDepartmentInput;
  images?: ImageUpdateManyInput;
}

export interface ImageRestrictedWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageRestrictedWhereInput[] | ImageRestrictedWhereInput;
}

export interface BrandUpdateManyWithoutDepartmentInput {
  create?:
    | BrandCreateWithoutDepartmentInput[]
    | BrandCreateWithoutDepartmentInput;
  delete?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  connect?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  set?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  disconnect?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  update?:
    | BrandUpdateWithWhereUniqueWithoutDepartmentInput[]
    | BrandUpdateWithWhereUniqueWithoutDepartmentInput;
  upsert?:
    | BrandUpsertWithWhereUniqueWithoutDepartmentInput[]
    | BrandUpsertWithWhereUniqueWithoutDepartmentInput;
  deleteMany?: BrandScalarWhereInput[] | BrandScalarWhereInput;
  updateMany?:
    | BrandUpdateManyWithWhereNestedInput[]
    | BrandUpdateManyWithWhereNestedInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface BrandUpdateWithWhereUniqueWithoutDepartmentInput {
  where: BrandWhereUniqueInput;
  data: BrandUpdateWithoutDepartmentDataInput;
}

export interface FeedSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FeedWhereInput;
  AND?: FeedSubscriptionWhereInput[] | FeedSubscriptionWhereInput;
}

export interface BrandUpdateWithoutDepartmentDataInput {
  name?: String;
  slug?: String;
  description?: String;
  images?: ImageUpdateManyInput;
  category?: CategoryUpdateManyWithoutBrandInput;
  product?: ProductUpdateManyWithoutBrandInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface ProductUpdateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    | ProductUpdateWithWhereUniqueWithoutBrandInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    | ProductUpsertWithWhereUniqueWithoutBrandInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
  birthdate?: DateTimeInput;
  email?: String;
}

export interface ProductUpdateWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutBrandDataInput;
}

export interface UserCreateInput {
  id?: ID_Input;
  username: String;
  password: String;
  birthdate?: DateTimeInput;
  email: String;
  posts?: FeedCreateManyWithoutAuthorInput;
  liked?: FeedCreateManyWithoutLikedInput;
}

export interface ProductUpdateWithoutBrandDataInput {
  isFeatured?: Boolean;
  name?: String;
  slug?: String;
  PID?: String;
  description?: String;
  category?: CategoryUpdateOneRequiredWithoutProductInput;
  entity?: ProductEntityUpdateManyWithoutProductInput;
}

export interface ProductUpsertWithoutEntityInput {
  update: ProductUpdateWithoutEntityDataInput;
  create: ProductCreateWithoutEntityInput;
}

export interface CategoryUpdateOneRequiredWithoutProductInput {
  create?: CategoryCreateWithoutProductInput;
  update?: CategoryUpdateWithoutProductDataInput;
  upsert?: CategoryUpsertWithoutProductInput;
  connect?: CategoryWhereUniqueInput;
}

export interface ProductUpdateWithoutEntityDataInput {
  isFeatured?: Boolean;
  name?: String;
  slug?: String;
  PID?: String;
  description?: String;
  brand?: BrandUpdateOneRequiredWithoutProductInput;
  category?: CategoryUpdateOneRequiredWithoutProductInput;
}

export interface CategoryUpdateWithoutProductDataInput {
  description?: String;
  name?: String;
  slug?: String;
  images?: ImageUpdateManyInput;
  brand?: BrandUpdateManyWithoutCategoryInput;
  department?: DepartmentUpdateManyWithoutCategoryInput;
}

export interface ProductEntityUpdateInput {
  color?: ColorUpdateOneRequiredInput;
  size?: SizeUpdateOneRequiredInput;
  images?: ImageUpdateManyInput;
  product?: ProductUpdateOneRequiredWithoutEntityInput;
  price?: Int;
  quantity?: Int;
  releaseDate?: DateTimeInput;
}

export interface BrandUpdateManyWithoutCategoryInput {
  create?: BrandCreateWithoutCategoryInput[] | BrandCreateWithoutCategoryInput;
  delete?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  connect?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  set?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  disconnect?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
  update?:
    | BrandUpdateWithWhereUniqueWithoutCategoryInput[]
    | BrandUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | BrandUpsertWithWhereUniqueWithoutCategoryInput[]
    | BrandUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: BrandScalarWhereInput[] | BrandScalarWhereInput;
  updateMany?:
    | BrandUpdateManyWithWhereNestedInput[]
    | BrandUpdateManyWithWhereNestedInput;
}

export interface ProductCreateWithoutEntityInput {
  id?: ID_Input;
  isFeatured?: Boolean;
  name: String;
  slug: String;
  PID: String;
  description?: String;
  brand: BrandCreateOneWithoutProductInput;
  category: CategoryCreateOneWithoutProductInput;
}

export interface BrandUpdateWithWhereUniqueWithoutCategoryInput {
  where: BrandWhereUniqueInput;
  data: BrandUpdateWithoutCategoryDataInput;
}

export interface ProductEntityCreateInput {
  id?: ID_Input;
  color: ColorCreateOneInput;
  size: SizeCreateOneInput;
  images?: ImageCreateManyInput;
  product: ProductCreateOneWithoutEntityInput;
  price: Int;
  quantity: Int;
  releaseDate?: DateTimeInput;
}

export interface BrandUpdateWithoutCategoryDataInput {
  name?: String;
  slug?: String;
  description?: String;
  images?: ImageUpdateManyInput;
  department?: DepartmentUpdateManyWithoutBrandInput;
  product?: ProductUpdateManyWithoutBrandInput;
}

export interface ProductUpdateManyMutationInput {
  isFeatured?: Boolean;
  name?: String;
  slug?: String;
  PID?: String;
  description?: String;
}

export interface DepartmentUpdateManyWithoutBrandInput {
  create?:
    | DepartmentCreateWithoutBrandInput[]
    | DepartmentCreateWithoutBrandInput;
  delete?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  set?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  disconnect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  update?:
    | DepartmentUpdateWithWhereUniqueWithoutBrandInput[]
    | DepartmentUpdateWithWhereUniqueWithoutBrandInput;
  upsert?:
    | DepartmentUpsertWithWhereUniqueWithoutBrandInput[]
    | DepartmentUpsertWithWhereUniqueWithoutBrandInput;
  deleteMany?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  updateMany?:
    | DepartmentUpdateManyWithWhereNestedInput[]
    | DepartmentUpdateManyWithWhereNestedInput;
}

export interface FeedWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  author?: UserWhereInput;
  liked_some?: UserWhereInput;
  AND?: FeedWhereInput[] | FeedWhereInput;
}

export interface DepartmentUpdateWithWhereUniqueWithoutBrandInput {
  where: DepartmentWhereUniqueInput;
  data: DepartmentUpdateWithoutBrandDataInput;
}

export interface ProductCreateInput {
  id?: ID_Input;
  isFeatured?: Boolean;
  name: String;
  slug: String;
  PID: String;
  description?: String;
  brand: BrandCreateOneWithoutProductInput;
  category: CategoryCreateOneWithoutProductInput;
  entity?: ProductEntityCreateManyWithoutProductInput;
}

export interface DepartmentUpdateWithoutBrandDataInput {
  description?: String;
  name?: String;
  slug?: String;
  category?: CategoryUpdateManyWithoutDepartmentInput;
  images?: ImageUpdateManyInput;
}

export interface UserUpdateManyDataInput {
  username?: String;
  password?: String;
  birthdate?: DateTimeInput;
  email?: String;
}

export interface FeedUpdateManyDataInput {
  description?: String;
  url?: String;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  birthdate?: DateTimeInput;
  birthdate_not?: DateTimeInput;
  birthdate_in?: DateTimeInput[] | DateTimeInput;
  birthdate_not_in?: DateTimeInput[] | DateTimeInput;
  birthdate_lt?: DateTimeInput;
  birthdate_lte?: DateTimeInput;
  birthdate_gt?: DateTimeInput;
  birthdate_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface CategoryUpdateWithWhereUniqueWithoutDepartmentInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutDepartmentDataInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedDataInput;
  create: UserCreateWithoutLikedInput;
}

export interface CategoryUpdateWithoutDepartmentDataInput {
  description?: String;
  name?: String;
  slug?: String;
  images?: ImageUpdateManyInput;
  brand?: BrandUpdateManyWithoutCategoryInput;
  product?: ProductUpdateManyWithoutCategoryInput;
}

export interface FeedUpdateWithoutAuthorDataInput {
  description?: String;
  url?: String;
  liked?: UserUpdateManyWithoutLikedInput;
}

export interface ProductUpdateManyWithoutCategoryInput {
  create?:
    | ProductCreateWithoutCategoryInput[]
    | ProductCreateWithoutCategoryInput;
  delete?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  set?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  disconnect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
  update?:
    | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    | ProductUpdateWithWhereUniqueWithoutCategoryInput;
  upsert?:
    | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    | ProductUpsertWithWhereUniqueWithoutCategoryInput;
  deleteMany?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  updateMany?:
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput;
}

export interface FeedUpdateWithWhereUniqueWithoutAuthorInput {
  where: FeedWhereUniqueInput;
  data: FeedUpdateWithoutAuthorDataInput;
}

export interface ProductUpdateWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateWithoutCategoryDataInput;
}

export interface UserUpdateWithoutLikedDataInput {
  username?: String;
  password?: String;
  birthdate?: DateTimeInput;
  email?: String;
  posts?: FeedUpdateManyWithoutAuthorInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  isFeatured?: Boolean;
  isFeatured_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  PID?: String;
  PID_not?: String;
  PID_in?: String[] | String;
  PID_not_in?: String[] | String;
  PID_lt?: String;
  PID_lte?: String;
  PID_gt?: String;
  PID_gte?: String;
  PID_contains?: String;
  PID_not_contains?: String;
  PID_starts_with?: String;
  PID_not_starts_with?: String;
  PID_ends_with?: String;
  PID_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  brand?: BrandWhereInput;
  category?: CategoryWhereInput;
  entity_some?: ProductEntityWhereInput;
  AND?: ProductWhereInput[] | ProductWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutLikedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedDataInput;
}

export interface ProductEntityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  color?: ColorWhereInput;
  size?: SizeWhereInput;
  images_some?: ImageWhereInput;
  images_every?: ImageRestrictedWhereInput;
  images_none?: ImageRestrictedWhereInput;
  product?: ProductWhereInput;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  releaseDate?: DateTimeInput;
  releaseDate_not?: DateTimeInput;
  releaseDate_in?: DateTimeInput[] | DateTimeInput;
  releaseDate_not_in?: DateTimeInput[] | DateTimeInput;
  releaseDate_lt?: DateTimeInput;
  releaseDate_lte?: DateTimeInput;
  releaseDate_gt?: DateTimeInput;
  releaseDate_gte?: DateTimeInput;
  AND?: ProductEntityWhereInput[] | ProductEntityWhereInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface BrandUpdateWithoutProductDataInput {
  name?: String;
  slug?: String;
  description?: String;
  images?: ImageUpdateManyInput;
  category?: CategoryUpdateManyWithoutBrandInput;
  department?: DepartmentUpdateManyWithoutBrandInput;
}

export interface BrandCreateInput {
  id?: ID_Input;
  name: String;
  slug: String;
  description: String;
  images?: ImageCreateManyInput;
  category?: CategoryCreateManyWithoutBrandInput;
  department?: DepartmentCreateManyWithoutBrandInput;
  product?: ProductCreateManyWithoutBrandInput;
}

export interface BrandUpsertWithoutProductInput {
  update: BrandUpdateWithoutProductDataInput;
  create: BrandCreateWithoutProductInput;
}

export interface ImageCreateInput {
  id?: ID_Input;
  url: String;
}

export interface ProductEntityUpdateManyWithoutProductInput {
  create?:
    | ProductEntityCreateWithoutProductInput[]
    | ProductEntityCreateWithoutProductInput;
  delete?: ProductEntityWhereUniqueInput[] | ProductEntityWhereUniqueInput;
  connect?: ProductEntityWhereUniqueInput[] | ProductEntityWhereUniqueInput;
  set?: ProductEntityWhereUniqueInput[] | ProductEntityWhereUniqueInput;
  disconnect?: ProductEntityWhereUniqueInput[] | ProductEntityWhereUniqueInput;
  update?:
    | ProductEntityUpdateWithWhereUniqueWithoutProductInput[]
    | ProductEntityUpdateWithWhereUniqueWithoutProductInput;
  upsert?:
    | ProductEntityUpsertWithWhereUniqueWithoutProductInput[]
    | ProductEntityUpsertWithWhereUniqueWithoutProductInput;
  deleteMany?: ProductEntityScalarWhereInput[] | ProductEntityScalarWhereInput;
  updateMany?:
    | ProductEntityUpdateManyWithWhereNestedInput[]
    | ProductEntityUpdateManyWithWhereNestedInput;
}

export interface CategoryCreateWithoutBrandInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  images?: ImageCreateManyInput;
  department?: DepartmentCreateManyWithoutCategoryInput;
  product?: ProductCreateManyWithoutCategoryInput;
}

export interface ProductEntityUpdateWithWhereUniqueWithoutProductInput {
  where: ProductEntityWhereUniqueInput;
  data: ProductEntityUpdateWithoutProductDataInput;
}

export interface DepartmentCreateWithoutCategoryInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  brand?: BrandCreateManyWithoutDepartmentInput;
  images?: ImageCreateManyInput;
}

export interface ProductEntityUpdateWithoutProductDataInput {
  color?: ColorUpdateOneRequiredInput;
  size?: SizeUpdateOneRequiredInput;
  images?: ImageUpdateManyInput;
  price?: Int;
  quantity?: Int;
  releaseDate?: DateTimeInput;
}

export interface BrandCreateWithoutDepartmentInput {
  id?: ID_Input;
  name: String;
  slug: String;
  description: String;
  images?: ImageCreateManyInput;
  category?: CategoryCreateManyWithoutBrandInput;
  product?: ProductCreateManyWithoutBrandInput;
}

export interface ColorUpdateOneRequiredInput {
  create?: ColorCreateInput;
  update?: ColorUpdateDataInput;
  upsert?: ColorUpsertNestedInput;
  connect?: ColorWhereUniqueInput;
}

export interface ProductCreateWithoutBrandInput {
  id?: ID_Input;
  isFeatured?: Boolean;
  name: String;
  slug: String;
  PID: String;
  description?: String;
  category: CategoryCreateOneWithoutProductInput;
  entity?: ProductEntityCreateManyWithoutProductInput;
}

export interface ColorUpdateDataInput {
  slug?: String;
  value?: String;
}

export interface CategoryCreateWithoutProductInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  images?: ImageCreateManyInput;
  brand?: BrandCreateManyWithoutCategoryInput;
  department?: DepartmentCreateManyWithoutCategoryInput;
}

export interface ColorUpsertNestedInput {
  update: ColorUpdateDataInput;
  create: ColorCreateInput;
}

export interface BrandCreateWithoutCategoryInput {
  id?: ID_Input;
  name: String;
  slug: String;
  description: String;
  images?: ImageCreateManyInput;
  department?: DepartmentCreateManyWithoutBrandInput;
  product?: ProductCreateManyWithoutBrandInput;
}

export type ColorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DepartmentCreateWithoutBrandInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  category?: CategoryCreateManyWithoutDepartmentInput;
  images?: ImageCreateManyInput;
}

export interface SizeUpdateOneRequiredInput {
  create?: SizeCreateInput;
  update?: SizeUpdateDataInput;
  upsert?: SizeUpsertNestedInput;
  connect?: SizeWhereUniqueInput;
}

export interface CategoryCreateWithoutDepartmentInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  images?: ImageCreateManyInput;
  brand?: BrandCreateManyWithoutCategoryInput;
  product?: ProductCreateManyWithoutCategoryInput;
}

export interface SizeUpdateDataInput {
  slug?: String;
  value?: String;
}

export interface ProductCreateWithoutCategoryInput {
  id?: ID_Input;
  isFeatured?: Boolean;
  name: String;
  slug: String;
  PID: String;
  description?: String;
  brand: BrandCreateOneWithoutProductInput;
  entity?: ProductEntityCreateManyWithoutProductInput;
}

export interface SizeUpsertNestedInput {
  update: SizeUpdateDataInput;
  create: SizeCreateInput;
}

export interface BrandCreateWithoutProductInput {
  id?: ID_Input;
  name: String;
  slug: String;
  description: String;
  images?: ImageCreateManyInput;
  category?: CategoryCreateManyWithoutBrandInput;
  department?: DepartmentCreateManyWithoutBrandInput;
}

export type SizeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductEntityCreateWithoutProductInput {
  id?: ID_Input;
  color: ColorCreateOneInput;
  size: SizeCreateOneInput;
  images?: ImageCreateManyInput;
  price: Int;
  quantity: Int;
  releaseDate?: DateTimeInput;
}

export interface ProductEntityUpsertWithWhereUniqueWithoutProductInput {
  where: ProductEntityWhereUniqueInput;
  update: ProductEntityUpdateWithoutProductDataInput;
  create: ProductEntityCreateWithoutProductInput;
}

export interface ColorCreateInput {
  id?: ID_Input;
  slug: String;
  value: String;
}

export interface ProductEntityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  quantity?: Int;
  quantity_not?: Int;
  quantity_in?: Int[] | Int;
  quantity_not_in?: Int[] | Int;
  quantity_lt?: Int;
  quantity_lte?: Int;
  quantity_gt?: Int;
  quantity_gte?: Int;
  releaseDate?: DateTimeInput;
  releaseDate_not?: DateTimeInput;
  releaseDate_in?: DateTimeInput[] | DateTimeInput;
  releaseDate_not_in?: DateTimeInput[] | DateTimeInput;
  releaseDate_lt?: DateTimeInput;
  releaseDate_lte?: DateTimeInput;
  releaseDate_gt?: DateTimeInput;
  releaseDate_gte?: DateTimeInput;
  AND?: ProductEntityScalarWhereInput[] | ProductEntityScalarWhereInput;
  OR?: ProductEntityScalarWhereInput[] | ProductEntityScalarWhereInput;
  NOT?: ProductEntityScalarWhereInput[] | ProductEntityScalarWhereInput;
}

export interface SizeCreateInput {
  id?: ID_Input;
  slug: String;
  value: String;
}

export interface ProductEntityUpdateManyWithWhereNestedInput {
  where: ProductEntityScalarWhereInput;
  data: ProductEntityUpdateManyDataInput;
}

export interface ImageUpdateManyInput {
  create?: ImageCreateInput[] | ImageCreateInput;
  update?:
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput;
  delete?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  deleteMany?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  updateMany?:
    | ImageUpdateManyWithWhereNestedInput[]
    | ImageUpdateManyWithWhereNestedInput;
}

export interface ProductEntityUpdateManyDataInput {
  price?: Int;
  quantity?: Int;
  releaseDate?: DateTimeInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductUpsertWithWhereUniqueWithoutCategoryInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutCategoryDataInput;
  create: ProductCreateWithoutCategoryInput;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface ProductScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  isFeatured?: Boolean;
  isFeatured_not?: Boolean;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  PID?: String;
  PID_not?: String;
  PID_in?: String[] | String;
  PID_not_in?: String[] | String;
  PID_lt?: String;
  PID_lte?: String;
  PID_gt?: String;
  PID_gte?: String;
  PID_contains?: String;
  PID_not_contains?: String;
  PID_starts_with?: String;
  PID_not_starts_with?: String;
  PID_ends_with?: String;
  PID_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  OR?: ProductScalarWhereInput[] | ProductScalarWhereInput;
  NOT?: ProductScalarWhereInput[] | ProductScalarWhereInput;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface CategoryUpdateManyWithoutBrandInput {
  create?: CategoryCreateWithoutBrandInput[] | CategoryCreateWithoutBrandInput;
  delete?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  set?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  disconnect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  update?:
    | CategoryUpdateWithWhereUniqueWithoutBrandInput[]
    | CategoryUpdateWithWhereUniqueWithoutBrandInput;
  upsert?:
    | CategoryUpsertWithWhereUniqueWithoutBrandInput[]
    | CategoryUpsertWithWhereUniqueWithoutBrandInput;
  deleteMany?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  updateMany?:
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput;
}

export interface ProductUpdateManyDataInput {
  isFeatured?: Boolean;
  name?: String;
  slug?: String;
  PID?: String;
  description?: String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CategoryUpsertWithWhereUniqueWithoutDepartmentInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutDepartmentDataInput;
  create: CategoryCreateWithoutDepartmentInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageWhereInput[] | ImageWhereInput;
}

export interface CategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  AND?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  OR?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  NOT?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DepartmentWhereInput;
  AND?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  birthdate?: DateTimeInput;
  email?: String;
  posts?: FeedUpdateManyWithoutAuthorInput;
  liked?: FeedUpdateManyWithoutLikedInput;
}

export interface CategoryUpdateManyDataInput {
  description?: String;
  name?: String;
  slug?: String;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DepartmentUpsertWithWhereUniqueWithoutBrandInput {
  where: DepartmentWhereUniqueInput;
  update: DepartmentUpdateWithoutBrandDataInput;
  create: DepartmentCreateWithoutBrandInput;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DepartmentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  AND?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  OR?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
  NOT?: DepartmentScalarWhereInput[] | DepartmentScalarWhereInput;
}

export type FeedWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DepartmentUpdateManyWithWhereNestedInput {
  where: DepartmentScalarWhereInput;
  data: DepartmentUpdateManyDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  birthdate?: DateTimeInput;
  birthdate_not?: DateTimeInput;
  birthdate_in?: DateTimeInput[] | DateTimeInput;
  birthdate_not_in?: DateTimeInput[] | DateTimeInput;
  birthdate_lt?: DateTimeInput;
  birthdate_lte?: DateTimeInput;
  birthdate_gt?: DateTimeInput;
  birthdate_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  posts_some?: FeedWhereInput;
  liked_some?: FeedWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
}

export interface DepartmentUpdateManyDataInput {
  description?: String;
  name?: String;
  slug?: String;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface BrandUpsertWithWhereUniqueWithoutCategoryInput {
  where: BrandWhereUniqueInput;
  update: BrandUpdateWithoutCategoryDataInput;
  create: BrandCreateWithoutCategoryInput;
}

export interface FeedUpsertWithWhereUniqueWithoutAuthorInput {
  where: FeedWhereUniqueInput;
  update: FeedUpdateWithoutAuthorDataInput;
  create: FeedCreateWithoutAuthorInput;
}

export interface BrandScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: BrandScalarWhereInput[] | BrandScalarWhereInput;
  OR?: BrandScalarWhereInput[] | BrandScalarWhereInput;
  NOT?: BrandScalarWhereInput[] | BrandScalarWhereInput;
}

export interface FeedUpdateManyWithoutAuthorInput {
  create?: FeedCreateWithoutAuthorInput[] | FeedCreateWithoutAuthorInput;
  delete?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  connect?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  set?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  disconnect?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  update?:
    | FeedUpdateWithWhereUniqueWithoutAuthorInput[]
    | FeedUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | FeedUpsertWithWhereUniqueWithoutAuthorInput[]
    | FeedUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: FeedScalarWhereInput[] | FeedScalarWhereInput;
  updateMany?:
    | FeedUpdateManyWithWhereNestedInput[]
    | FeedUpdateManyWithWhereNestedInput;
}

export interface BrandUpdateManyWithWhereNestedInput {
  where: BrandScalarWhereInput;
  data: BrandUpdateManyDataInput;
}

export interface UserUpdateManyWithoutLikedInput {
  create?: UserCreateWithoutLikedInput[] | UserCreateWithoutLikedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLikedInput[]
    | UserUpdateWithWhereUniqueWithoutLikedInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLikedInput[]
    | UserUpsertWithWhereUniqueWithoutLikedInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface BrandUpdateManyDataInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface ImageCreateManyInput {
  create?: ImageCreateInput[] | ImageCreateInput;
}

export interface CategoryUpsertWithoutProductInput {
  update: CategoryUpdateWithoutProductDataInput;
  create: CategoryCreateWithoutProductInput;
}

export interface DepartmentCreateManyWithoutCategoryInput {
  create?:
    | DepartmentCreateWithoutCategoryInput[]
    | DepartmentCreateWithoutCategoryInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
}

export interface ProductUpsertWithWhereUniqueWithoutBrandInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateWithoutBrandDataInput;
  create: ProductCreateWithoutBrandInput;
}

export interface ProductCreateManyWithoutBrandInput {
  create?: ProductCreateWithoutBrandInput[] | ProductCreateWithoutBrandInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface BrandUpsertWithWhereUniqueWithoutDepartmentInput {
  where: BrandWhereUniqueInput;
  update: BrandUpdateWithoutDepartmentDataInput;
  create: BrandCreateWithoutDepartmentInput;
}

export interface BrandCreateManyWithoutCategoryInput {
  create?: BrandCreateWithoutCategoryInput[] | BrandCreateWithoutCategoryInput;
  connect?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
}

export interface DepartmentUpsertWithWhereUniqueWithoutCategoryInput {
  where: DepartmentWhereUniqueInput;
  update: DepartmentUpdateWithoutCategoryDataInput;
  create: DepartmentCreateWithoutCategoryInput;
}

export interface CategoryCreateManyWithoutDepartmentInput {
  create?:
    | CategoryCreateWithoutDepartmentInput[]
    | CategoryCreateWithoutDepartmentInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
}

export interface CategoryUpsertWithWhereUniqueWithoutBrandInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutBrandDataInput;
  create: CategoryCreateWithoutBrandInput;
}

export interface BrandCreateOneWithoutProductInput {
  create?: BrandCreateWithoutProductInput;
  connect?: BrandWhereUniqueInput;
}

export interface BrandUpdateManyMutationInput {
  name?: String;
  slug?: String;
  description?: String;
}

export interface ColorCreateOneInput {
  create?: ColorCreateInput;
}

export interface FeedUpdateManyWithWhereNestedInput {
  where: FeedScalarWhereInput;
  data: FeedUpdateManyDataInput;
}

export interface BrandUpdateInput {
  name?: String;
  slug?: String;
  description?: String;
  images?: ImageUpdateManyInput;
  category?: CategoryUpdateManyWithoutBrandInput;
  department?: DepartmentUpdateManyWithoutBrandInput;
  product?: ProductUpdateManyWithoutBrandInput;
}

export interface FeedScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FeedScalarWhereInput[] | FeedScalarWhereInput;
  OR?: FeedScalarWhereInput[] | FeedScalarWhereInput;
  NOT?: FeedScalarWhereInput[] | FeedScalarWhereInput;
}

export interface ImageUpdateDataInput {
  url?: String;
}

export interface CategoryCreateInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  images?: ImageCreateManyInput;
  brand?: BrandCreateManyWithoutCategoryInput;
  department?: DepartmentCreateManyWithoutCategoryInput;
  product?: ProductCreateManyWithoutCategoryInput;
}

export interface ImageUpdateManyDataInput {
  url?: String;
}

export interface CategoryUpdateInput {
  description?: String;
  name?: String;
  slug?: String;
  images?: ImageUpdateManyInput;
  brand?: BrandUpdateManyWithoutCategoryInput;
  department?: DepartmentUpdateManyWithoutCategoryInput;
  product?: ProductUpdateManyWithoutCategoryInput;
}

export interface ProductEntitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductEntityWhereInput;
  AND?:
    | ProductEntitySubscriptionWhereInput[]
    | ProductEntitySubscriptionWhereInput;
}

export interface CategoryUpdateManyMutationInput {
  description?: String;
  name?: String;
  slug?: String;
}

export interface BrandSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BrandWhereInput;
  AND?: BrandSubscriptionWhereInput[] | BrandSubscriptionWhereInput;
}

export interface DepartmentCreateInput {
  id?: ID_Input;
  description: String;
  name: String;
  slug: String;
  brand?: BrandCreateManyWithoutDepartmentInput;
  category?: CategoryCreateManyWithoutDepartmentInput;
  images?: ImageCreateManyInput;
}

export interface ProductUpdateOneRequiredWithoutEntityInput {
  create?: ProductCreateWithoutEntityInput;
  update?: ProductUpdateWithoutEntityDataInput;
  upsert?: ProductUpsertWithoutEntityInput;
  connect?: ProductWhereUniqueInput;
}

export interface DepartmentUpdateInput {
  description?: String;
  name?: String;
  slug?: String;
  brand?: BrandUpdateManyWithoutDepartmentInput;
  category?: CategoryUpdateManyWithoutDepartmentInput;
  images?: ImageUpdateManyInput;
}

export interface ProductUpdateInput {
  isFeatured?: Boolean;
  name?: String;
  slug?: String;
  PID?: String;
  description?: String;
  brand?: BrandUpdateOneRequiredWithoutProductInput;
  category?: CategoryUpdateOneRequiredWithoutProductInput;
  entity?: ProductEntityUpdateManyWithoutProductInput;
}

export interface DepartmentUpdateManyMutationInput {
  description?: String;
  name?: String;
  slug?: String;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FeedCreateInput {
  id?: ID_Input;
  description: String;
  url: String;
  author: UserCreateOneWithoutPostsInput;
  liked?: UserCreateManyWithoutLikedInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
  email?: String;
}>;

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface CategoryCreateManyWithoutBrandInput {
  create?: CategoryCreateWithoutBrandInput[] | CategoryCreateWithoutBrandInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
}

export interface UserCreateWithoutPostsInput {
  id?: ID_Input;
  username: String;
  password: String;
  birthdate?: DateTimeInput;
  email: String;
  liked?: FeedCreateManyWithoutLikedInput;
}

export interface CategoryCreateOneWithoutProductInput {
  create?: CategoryCreateWithoutProductInput;
  connect?: CategoryWhereUniqueInput;
}

export interface FeedCreateManyWithoutLikedInput {
  create?: FeedCreateWithoutLikedInput[] | FeedCreateWithoutLikedInput;
  connect?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
}

export interface ProductCreateManyWithoutCategoryInput {
  create?:
    | ProductCreateWithoutCategoryInput[]
    | ProductCreateWithoutCategoryInput;
  connect?: ProductWhereUniqueInput[] | ProductWhereUniqueInput;
}

export interface FeedCreateWithoutLikedInput {
  id?: ID_Input;
  description: String;
  url: String;
  author: UserCreateOneWithoutPostsInput;
}

export interface SizeCreateOneInput {
  create?: SizeCreateInput;
}

export interface UserCreateManyWithoutLikedInput {
  create?: UserCreateWithoutLikedInput[] | UserCreateWithoutLikedInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  OR?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  NOT?: ImageScalarWhereInput[] | ImageScalarWhereInput;
}

export interface UserCreateWithoutLikedInput {
  id?: ID_Input;
  username: String;
  password: String;
  birthdate?: DateTimeInput;
  email: String;
  posts?: FeedCreateManyWithoutAuthorInput;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  images_some?: ImageWhereInput;
  images_every?: ImageRestrictedWhereInput;
  images_none?: ImageRestrictedWhereInput;
  brand_some?: BrandWhereInput;
  department_some?: DepartmentWhereInput;
  product_some?: ProductWhereInput;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface FeedCreateManyWithoutAuthorInput {
  create?: FeedCreateWithoutAuthorInput[] | FeedCreateWithoutAuthorInput;
  connect?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
}

export interface ProductCreateOneWithoutEntityInput {
  create?: ProductCreateWithoutEntityInput;
  connect?: ProductWhereUniqueInput;
}

export interface FeedCreateWithoutAuthorInput {
  id?: ID_Input;
  description: String;
  url: String;
  liked?: UserCreateManyWithoutLikedInput;
}

export type ProductEntityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FeedUpdateInput {
  description?: String;
  url?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  liked?: UserUpdateManyWithoutLikedInput;
}

export interface BrandCreateManyWithoutDepartmentInput {
  create?:
    | BrandCreateWithoutDepartmentInput[]
    | BrandCreateWithoutDepartmentInput;
  connect?: BrandWhereUniqueInput[] | BrandWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface ProductEntityCreateManyWithoutProductInput {
  create?:
    | ProductEntityCreateWithoutProductInput[]
    | ProductEntityCreateWithoutProductInput;
  connect?: ProductEntityWhereUniqueInput[] | ProductEntityWhereUniqueInput;
}

export interface ColorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: ColorWhereInput[] | ColorWhereInput;
}

export interface FeedUpdateWithoutLikedDataInput {
  description?: String;
  url?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
}

export interface FeedUpdateWithWhereUniqueWithoutLikedInput {
  where: FeedWhereUniqueInput;
  data: FeedUpdateWithoutLikedDataInput;
}

export interface FeedUpdateManyWithoutLikedInput {
  create?: FeedCreateWithoutLikedInput[] | FeedCreateWithoutLikedInput;
  delete?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  connect?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  set?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  disconnect?: FeedWhereUniqueInput[] | FeedWhereUniqueInput;
  update?:
    | FeedUpdateWithWhereUniqueWithoutLikedInput[]
    | FeedUpdateWithWhereUniqueWithoutLikedInput;
  upsert?:
    | FeedUpsertWithWhereUniqueWithoutLikedInput[]
    | FeedUpsertWithWhereUniqueWithoutLikedInput;
  deleteMany?: FeedScalarWhereInput[] | FeedScalarWhereInput;
  updateMany?:
    | FeedUpdateManyWithWhereNestedInput[]
    | FeedUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutPostsDataInput {
  username?: String;
  password?: String;
  birthdate?: DateTimeInput;
  email?: String;
  liked?: FeedUpdateManyWithoutLikedInput;
}

export interface ProductEntityUpdateManyMutationInput {
  price?: Int;
  quantity?: Int;
  releaseDate?: DateTimeInput;
}

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface DepartmentCreateManyWithoutBrandInput {
  create?:
    | DepartmentCreateWithoutBrandInput[]
    | DepartmentCreateWithoutBrandInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
}

export interface FeedUpdateManyMutationInput {
  description?: String;
  url?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
  birthdate?: DateTimeOutput;
  email: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  birthdate: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface Category {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
  slug: String;
  images?: <T = FragmentableArray<Image>>() => T;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  images: <T = FragmentableArray<Image>>() => T;
  brand: <T = FragmentableArray<Brand>>(args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  department: <T = FragmentableArray<Department>>(args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  product: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>() => T;
  brand: <T = Promise<AsyncIterator<BrandSubscription>>>(args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  department: <T = Promise<AsyncIterator<DepartmentSubscription>>>(args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  product: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateBrand {
  count: Int;
}

export interface AggregateBrandPromise
  extends Promise<AggregateBrand>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrandSubscription
  extends Promise<AsyncIterator<AggregateBrand>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrandEdge {
  node: Brand;
  cursor: String;
}

export interface BrandEdgePromise extends Promise<BrandEdge>, Fragmentable {
  node: <T = BrandPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrandEdgeSubscription
  extends Promise<AsyncIterator<BrandEdge>>,
    Fragmentable {
  node: <T = BrandSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface BrandConnection {
  pageInfo: PageInfo;
  edges: BrandEdge[];
}

export interface BrandConnectionPromise
  extends Promise<BrandConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrandEdge>>() => T;
  aggregate: <T = AggregateBrandPromise>() => T;
}

export interface BrandConnectionSubscription
  extends Promise<AsyncIterator<BrandConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrandEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrandSubscription>() => T;
}

export interface ProductEntityEdge {
  node: ProductEntity;
  cursor: String;
}

export interface ProductEntityEdgePromise
  extends Promise<ProductEntityEdge>,
    Fragmentable {
  node: <T = ProductEntityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEntityEdgeSubscription
  extends Promise<AsyncIterator<ProductEntityEdge>>,
    Fragmentable {
  node: <T = ProductEntitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Size {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  value: String;
}

export interface SizePromise extends Promise<Size>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  value: () => Promise<String>;
}

export interface SizeSubscription
  extends Promise<AsyncIterator<Size>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Color {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  slug: String;
  value: String;
}

export interface ColorPromise extends Promise<Color>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  slug: () => Promise<String>;
  value: () => Promise<String>;
}

export interface ColorSubscription
  extends Promise<AsyncIterator<Color>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  slug: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface Brand {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  slug: String;
  description: String;
  images?: <T = FragmentableArray<Image>>() => T;
}

export interface BrandPromise extends Promise<Brand>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
  images: <T = FragmentableArray<Image>>() => T;
  category: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  department: <T = FragmentableArray<Department>>(args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  product: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BrandSubscription
  extends Promise<AsyncIterator<Brand>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>() => T;
  category: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  department: <T = Promise<AsyncIterator<DepartmentSubscription>>>(args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  product: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FeedEdge {
  node: Feed;
  cursor: String;
}

export interface FeedEdgePromise extends Promise<FeedEdge>, Fragmentable {
  node: <T = FeedPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FeedEdgeSubscription
  extends Promise<AsyncIterator<FeedEdge>>,
    Fragmentable {
  node: <T = FeedSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BrandSubscriptionPayload {
  mutation: MutationType;
  node: Brand;
  updatedFields: String[];
  previousValues: BrandPreviousValues;
}

export interface BrandSubscriptionPayloadPromise
  extends Promise<BrandSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrandPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrandPreviousValuesPromise>() => T;
}

export interface BrandSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrandSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrandSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrandPreviousValuesSubscription>() => T;
}

export interface ProductEntityPreviousValues {
  id: ID_Output;
  price: Int;
  quantity: Int;
  releaseDate?: DateTimeOutput;
}

export interface ProductEntityPreviousValuesPromise
  extends Promise<ProductEntityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Int>;
  quantity: () => Promise<Int>;
  releaseDate: () => Promise<DateTimeOutput>;
}

export interface ProductEntityPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductEntityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BrandPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  slug: String;
  description: String;
}

export interface BrandPreviousValuesPromise
  extends Promise<BrandPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BrandPreviousValuesSubscription
  extends Promise<AsyncIterator<BrandPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
  birthdate?: DateTimeOutput;
  email: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  birthdate: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  posts: <T = FragmentableArray<Feed>>(args?: {
    where?: FeedWhereInput;
    orderBy?: FeedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  liked: <T = FragmentableArray<Feed>>(args?: {
    where?: FeedWhereInput;
    orderBy?: FeedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  birthdate: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  posts: <T = Promise<AsyncIterator<FeedSubscription>>>(args?: {
    where?: FeedWhereInput;
    orderBy?: FeedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  liked: <T = Promise<AsyncIterator<FeedSubscription>>>(args?: {
    where?: FeedWhereInput;
    orderBy?: FeedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductEntity {
  id: ID_Output;
  color: Color;
  size: Size;
  images?: <T = FragmentableArray<Image>>() => T;
  price: Int;
  quantity: Int;
  releaseDate?: DateTimeOutput;
}

export interface ProductEntityPromise
  extends Promise<ProductEntity>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  color: <T = ColorPromise>() => T;
  size: <T = SizePromise>() => T;
  images: <T = FragmentableArray<Image>>() => T;
  product: <T = ProductPromise>() => T;
  price: () => Promise<Int>;
  quantity: () => Promise<Int>;
  releaseDate: () => Promise<DateTimeOutput>;
}

export interface ProductEntitySubscription
  extends Promise<AsyncIterator<ProductEntity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  color: <T = ColorSubscription>() => T;
  size: <T = SizeSubscription>() => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>() => T;
  product: <T = ProductSubscription>() => T;
  price: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
  slug: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Image {
  id: ID_Output;
  createdAt: DateTimeOutput;
  url: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface ProductEntityConnection {
  pageInfo: PageInfo;
  edges: ProductEntityEdge[];
}

export interface ProductEntityConnectionPromise
  extends Promise<ProductEntityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEntityEdge>>() => T;
  aggregate: <T = AggregateProductEntityPromise>() => T;
}

export interface ProductEntityConnectionSubscription
  extends Promise<AsyncIterator<ProductEntityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEntityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductEntitySubscription>() => T;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
  slug: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFeed {
  count: Int;
}

export interface AggregateFeedPromise
  extends Promise<AggregateFeed>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFeedSubscription
  extends Promise<AsyncIterator<AggregateFeed>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isFeatured?: Boolean;
  name: String;
  slug: String;
  PID: String;
  description?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isFeatured: () => Promise<Boolean>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  PID: () => Promise<String>;
  description: () => Promise<String>;
  brand: <T = BrandPromise>() => T;
  category: <T = CategoryPromise>() => T;
  entity: <T = FragmentableArray<ProductEntity>>(args?: {
    where?: ProductEntityWhereInput;
    orderBy?: ProductEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isFeatured: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  PID: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  brand: <T = BrandSubscription>() => T;
  category: <T = CategorySubscription>() => T;
  entity: <T = Promise<AsyncIterator<ProductEntitySubscription>>>(args?: {
    where?: ProductEntityWhereInput;
    orderBy?: ProductEntityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductEntitySubscriptionPayload {
  mutation: MutationType;
  node: ProductEntity;
  updatedFields: String[];
  previousValues: ProductEntityPreviousValues;
}

export interface ProductEntitySubscriptionPayloadPromise
  extends Promise<ProductEntitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductEntityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductEntityPreviousValuesPromise>() => T;
}

export interface ProductEntitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductEntitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductEntitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductEntityPreviousValuesSubscription>() => T;
}

export interface FeedSubscriptionPayload {
  mutation: MutationType;
  node: Feed;
  updatedFields: String[];
  previousValues: FeedPreviousValues;
}

export interface FeedSubscriptionPayloadPromise
  extends Promise<FeedSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FeedPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FeedPreviousValuesPromise>() => T;
}

export interface FeedSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FeedSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FeedSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FeedPreviousValuesSubscription>() => T;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isFeatured?: Boolean;
  name: String;
  slug: String;
  PID: String;
  description?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isFeatured: () => Promise<Boolean>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  PID: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isFeatured: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  PID: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface Department {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
  slug: String;
  images?: <T = FragmentableArray<Image>>() => T;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
  brand: <T = FragmentableArray<Brand>>(args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>() => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  brand: <T = Promise<AsyncIterator<BrandSubscription>>>(args?: {
    where?: BrandWhereInput;
    orderBy?: BrandOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  category: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>() => T;
}

export interface FeedPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  url: String;
}

export interface FeedPreviousValuesPromise
  extends Promise<FeedPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FeedPreviousValuesSubscription
  extends Promise<AsyncIterator<FeedPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductEntity {
  count: Int;
}

export interface AggregateProductEntityPromise
  extends Promise<AggregateProductEntity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductEntitySubscription
  extends Promise<AsyncIterator<AggregateProductEntity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Feed {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  url: String;
}

export interface FeedPromise extends Promise<Feed>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  author: <T = UserPromise>() => T;
  liked: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FeedSubscription
  extends Promise<AsyncIterator<Feed>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  liked: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface FeedConnection {
  pageInfo: PageInfo;
  edges: FeedEdge[];
}

export interface FeedConnectionPromise
  extends Promise<FeedConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FeedEdge>>() => T;
  aggregate: <T = AggregateFeedPromise>() => T;
}

export interface FeedConnectionSubscription
  extends Promise<AsyncIterator<FeedConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FeedEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFeedSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Brand",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Color",
    embedded: true
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "Feed",
    embedded: false
  },
  {
    name: "Image",
    embedded: true
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductEntity",
    embedded: false
  },
  {
    name: "Size",
    embedded: true
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
